---
title: "【C++】あらゆる変数をprintするdump関数を本気で作ってみた"
emoji: "⛳"
type: "tech"
topics:
  - "cpp"
  - "競技プログラミング"
  - "atcoder"
published: true
published_at: "2023-09-27 13:55"
---

## はじめに

Python の`print()`、JavaScript の`console.log()`、PHP の`var_dump()`はあらゆる型の変数を print できる関数です。これらはデバッガのようにセットアップしたり、ブレークポイントを設定したりせずにすぐに変数の中身を確認することができ、デバッグの手段としてめちゃくちゃ便利です。

でも、C++にはこんな関数はありません。なので、例えば vector の中身を print したい！と思っても、**いちいち for ループを書いて、cout << a[i] << endl;なんてやらなければなりません。** もし Python みたいに`print(変数名1, 変数名2, ...)`とするだけで、あらゆる変数の中身を表示することが出来たら…。

そこで、あらゆる型の変数を自動でフォーマットしてプリントするライブラリ cpp-dump を**本気で作ってみました！** オートインデント機能、色付きの出力、JavaScript、Python、C++ に似た文字列表現、20 種類以上のマニピュレータなど、cpp-dump は変数を手軽に分かりやすくプリントするためにあらゆる機能を備えています。

このライブラリの特徴:

- 多次元配列や多次元の(多重)マップ、(多重)セット、タプル、複素数やエラーオブジェクトまで、**どんな型の変数でも**、文字列表現にして標準エラー出力(カスタマイズ可能)に出力する。
- **自動インデント機能付き。** 設定した行幅に収まるように自動でインデントされ、ネストしたコンテナも読みやすいようにフォーマットされる。
- 変数の文字列表現は JavaScript や Python, C++のシンタックスに似ていて、**情報過多で見づらくなることもない、読みやすい出力。** (マニピュレータで情報を付加することもできる)
- **出力は色付きで、カスタマイズ可能。** IDE のシンタックスハイライトのような色付けも可能。
- **20 種類以上のマニピュレータ付き**で簡単に出力のフォーマットを変えたり情報を付加したりできる。
- マクロを使うか演算子を定義すると**ユーザー定義型もダンプできる。** 新しく関数を書いたりする必要はない。
- **ヘッダーオンリーライブラリ**で、ビルドなどは不要。

https://github.com/philip82148/cpp-dump

## 使い方

`cpp_dump(expr...)`マクロに変数を渡すだけです！
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/introduction.cpp)

```cpp
std::vector<std::vector<int>> my_vector{{3, 5, 8, 9, 7}, {9, 3, 2, 3, 8}};
cpp_dump(my_vector);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/macro-version.png?3)

## このライブラリの特徴

### 幅広い型に対応

対応している型は vector だけではありません。map, set, tuple, pair など、ありとあらゆる型に対応しています。  
[サポートしている全ての型を見る](https://github.com/philip82148/cpp-dump?tab=readme-ov-file#supported-types)
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/supports-various-types.cpp)

```cpp
// 変数の定義はサンプルコードを見てください
std::clog << "\n// Basic Type" << std::endl;
cpp_dump(false, 0, 0.0); cpp_dump(true, 3.14, my_int, -9265);
cpp_dump("This is a string.", 'a', '\n'); cpp_dump(ptr, void_ptr, nullptr);

std::clog << "\n// Container" << std::endl;
cpp_dump(my_vector);

std::clog << "\n// Set/Map" << std::endl;
cpp_dump(my_set); cpp_dump(my_map);

std::clog << "\n// Multiset/Multimap" << std::endl;
cpp_dump(my_multiset); cpp_dump(my_multimap);

std::clog << "\n// Tuple" << std::endl;
cpp_dump(my_tuple); cpp_dump(my_pair);

std::clog << "\n// FIFO/LIFO" << std::endl;
cpp_dump(my_queue); cpp_dump(my_priority_queue); cpp_dump(my_stack);

std::clog << "\n// Other" << std::endl;
cpp_dump(my_bitset); cpp_dump(my_complex);
cpp_dump(my_optional, std::nullopt); cpp_dump(my_variant);

std::clog << "\n// Combination" << std::endl;
cpp_dump(vector_of_pairs);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/supports-various-types.png?6)

### 設定した行幅に収まるように自動でインデント

要素を追加して行幅を超えそうになると**自動でインデントされます！！**  
ちなみに多次元配列などは最初から改行されます(設定変更可能)。  
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/auto-indent.cpp)

```cpp
std::vector<std::string> my_vector(3, "This is a test string.");

cpp_dump(my_vector);
my_vector.push_back("This is a test string.");
cpp_dump(my_vector);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/auto-indent.png?3)

### `[dump]`の代わりにファイル名や行数を表示させることも可能

`[dump]`の代わりにファイル名や行数を表示させることも可能です。
その場合は以下のコードで設定します。
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/customize-dump.cpp)

```cpp
// Print the filename and line instead of [dump]
CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename());
// Print along with the function name
CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename(true));
```

![](https://github.com/philip82148/cpp-dump/blob/main/readme/customize-dump.png)

### 出力のカラーリングはカスタマイズ可能

以下のコードのようにすることで出力のカラーリングをカスタマイズできます。
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/customizable-colors.cpp)

```cpp
// 色数を増やす
CPP_DUMP_SET_OPTION(es_value, (cp::types::es_value_t{
  "\x1b[02m",        // log: dark
  "\x1b[34m",        // expression: blue
  "\x1b[38;5;39m",   // reserved: light blue
  "\x1b[38;5;193m",  // number: light green
  "\x1b[38;5;172m",  // character: orange
  "\x1b[02m",        // op: dark
  "\x1b[32m",        // identifier:  green
  "\x1b[96m",        // member: light cyan
  "\x1b[31m",        // unsupported: red
  {
    "\x1b[33m",      // bracket_by_depth[0]: yellow
    "\x1b[35m",      // bracket_by_depth[1]: magenta
    "\x1b[36m",      // bracket_by_depth[2]: cyan
  },
  "\x1b[02m",        // class_op: dark
  "\x1b[02m",        // member_op: dark
  "",                // number_op: default
  "\x1b[38;5;220m"   // escaped_char: light orange
}));

// クラスやメンバ、数値の演算子(::, <>, (), -, +, etc...)に
// 色(class_op, member_op, number_op)を付ける
CPP_DUMP_SET_OPTION(detailed_class_es, true);
CPP_DUMP_SET_OPTION(detailed_member_es, true);
CPP_DUMP_SET_OPTION(detailed_number_es, true);

// IDEのシンタックスハイライトのようなカラーリングにする
// CPP_DUMP_SET_OPTION(es_style, cp::types::es_style_t::by_syntax);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/customizable-colors.png?6)

### ユーザー定義型も対応させることが可能

マクロを使うか演算子を定義することで、ユーザー定義型も対応させることが可能です。
[完全なサンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/user-defined-class2.cpp)

```cpp
CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(i, str());
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/user-defined-class2.png?2)

### 20 種類以上のマニピュレータ

このライブラリには 20 種類以上のマニピュレータがあり、簡単にフォーマットを変更したり、情報を付加したりすることができます。
![](https://github.com/philip82148/cpp-dump/blob/main/readme/manipulator-front-etc.png)
_配列の一部を省略するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/raw/main/readme/manipulator-index.png?1)
_配列のインデックスを表示するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/blob/main/readme/manipulator-ubin-etc.png?1)
_数値の基数を変更するマニピュレータ_

## このライブラリを使うのに必要な要件

- C++17 以上
- ヘッダーオンリーライブラリなので追加のビルドや依存関係などはありません！

## インストール方法

1. リポジトリを好きな場所にダウンロードします。

**git が使える人は**

```shell
git clone https://github.com/philip82148/cpp-dump
```

**git が使えない人は**
[Releases](https://github.com/philip82148/cpp-dump/releases)からソースフォルダをダウンロードして、好きな場所に解凍しましょう。

2. ソースファイル内で、`cpp-dump/dump.hpp`を include します。

```cpp
#include "path/to/cpp-dump/dump.hpp"
```

ダウンロードしたフォルダ内にある`dump.hpp`というファイルをソースフォルダ内で include します。  
※パスは自身の環境に合わせて変えてください。

## カスタマイズ方法

カスタマイズする際は、`CPP_DUMP_SET_OPTION_GLOBAL()`で設定を行います。

```cpp:custom-cpp-dump.hpp
#ifdef DEBUGGING
#include "path/to/cpp-dump/cpp-dump.hpp"
namespace cp = cpp_dump;
CPP_DUMP_SET_OPTION_GLOBAL(max_line_width, 100);
// CPP_DUMP_DEFINE_EXPORT_ENUM(...);
// CPP_DUMP_DEFINE_EXPORT_OBJECT(...);
// CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(...);
#else
#define cpp_dump(...)
#define CPP_DUMP_SET_OPTION(...)
#endif
```

```cpp:main.cpp
#include "path/to/custom-cpp-dump.hpp"

int main() {
  cpp_dump(vec | cp::back());
}
```

関数の中で設定を変更したい場合は`CPP_DUMP_SET_OPTION()`を使います。

```cpp:main.cpp
#include "path/to/custom-cpp-dump.hpp"

void func() {
  CPP_DUMP_SET_OPTION(print_expr, false);
  cpp_dump(vec | cp::back());
  CPP_DUMP_SET_OPTION(print_expr, true);
}
```

### 設定可能項目

#### `max_line_width`

型: `std::size_t` デフォルト値: `160`

`cpp_dump()`と、その内部で使われている`cpp_dump::export_var()`が出力する文字列の最大行幅。

#### `max_depth`

型: `std::size_t` デフォルト値: `4`

`cpp_dump::export_var()`が再帰的に呼び出される最大の回数。

#### `max_iteration_count`

型: `std::size_t` デフォルト値: `16`
コンテナなどで、`cpp_dump::export_var()`をイテレーションする回数。`cpp_dump::export_var()`の一回の呼び出しで`cpp_dump::export_var()`は最大(`max_iteration_count`^(`max_depth`+1)-1)/(`max_iteration_count`-1)-1 回呼び出される。

#### `enable_asterisk`

型: `bool` デフォルト値: `false`
`cpp_dump::export_var()`が型カテゴリ Asterisk をプリントするかどうか。(詳細は[README の Supported types](#supported-types)を参照)

#### `print_expr`

型: `bool` デフォルト値: `true`
`cpp_dump()`が式を表示するかどうか。

#### `log_label_func`

型: `cpp_dump::types::log_label_func_t` デフォルト値 `cpp_dump::log_label::default_func`  
`cpp_dump()`が出力の最初にプリントするラベルを返す関数。

#### `es_style`

型: `enum class cpp_dump::types::es_style_t` デフォルト値`cpp_dump::types::es_style_t::original`  
出力のカラースキーム。

| オプション名 | 説明                                                                                                                |
| ------------ | ------------------------------------------------------------------------------------------------------------------- |
| `original`   | デフォルト値                                                                                                        |
| `by_syntax`  | 標準的なシンタックスハイライトと同様の色付けにする。ポインタや bitset、complex などが`original`とは違う色付けになる |
| `no_es`      | 色付けをオフにする                                                                                                  |

#### `es_value`

型: `cpp_dump::types::es_value_t` デフォルト値: (デフォルトコンストラクタ、[型](#types)を参照)  
エスケープシーケンスの値。

#### `detailed_class_es`

型: `bool` デフォルト値: `false`  
`true` にすると、クラス名の演算子 (`::`、`<>` など) に 'class_op' カラーが使用される。

#### `detailed_member_es`

型: `bool` デフォルト値: `false`  
`true` にすると、メンバの演算子 (`()` など) に 'member_op' カラーが使用される。

#### `detailed_number_es`

型: `bool` デフォルト値: `false`  
`true` に設定すると、数値内の演算子 (`-`、`+` など) に 'number_op' カラーが使用される。

#### `cont_indent_style`

型: `enum class cpp_dump::types::cont_indent_style_t` デフォルト値: `cpp_dump::types::cont_indent_style_t::when_nested`  
型カテゴリ Container、Set、Map のインデントのスタイル([対応する型](#supported-types)参照)。

| オプション名             | 説明                                                                                                                 |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| `minimal`                | `max_line_width` が超えない限りインデントしない                                                                      |
| `when_nested`            | デフォルト。要素/キー/値の型が型カテゴリ Container/Set/Map/Tuple ならば常にインデントする。                          |
| `when_non_tuples_nested` | 要素/キー/値の型が型カテゴリ Container/Set/Map ならば常にインデントする。型カテゴリ Tuple の場合はインデントしない。 |
| `always`                 | Container/Set/Map がネストされていなくても常にインデントする。                                                       |

## 詳細な使用方法

### ユーザー定義型を print する方法

ユーザー定義型を print するためには、3 つの方法があります。

#### 方法 1. CPP_DUMP_DEFINE_EXPORT_OBJECT() マクロを使用する

これは最も安全・簡単に`cpp_dump()`をユーザー定義型に対応させる方法です。  
[完全なサンプルコードを見る](./readme/user-defined-class.cpp)

```cpp
// グローバルスコープからアクセス可能な場所（プライベート、または関数内で定義されていない）に配置
struct class_A {
  int i;
  std::string str() const { return std::to_string(i); }
};

// グローバルスコープ内
// CPP_DUMP_DEFINE_EXPORT_OBJECT(type_name, members...)
CPP_DUMP_DEFINE_EXPORT_OBJECT(class_A, i, str());

// 関数内
class_A my_class_A{10};
cpp_dump(my_class_A);
```

![user-defined-class.png](./readme/user-defined-class.png)

enum に対しては、CPP_DUMP_DEFINE_EXPORT_ENUM()があります。  
[完全なサンプルコードを見る](./readme/user-defined-enum.cpp)

```cpp
// グローバルスコープからアクセス可能な場所（プライベート、または関数内で定義されていない）に配置
enum class enum_A { a, b, c };

// グローバルスコープ内
// CPP_DUMP_DEFINE_EXPORT_ENUM(enum_name, members...)
CPP_DUMP_DEFINE_EXPORT_ENUM(enum_A, enum_A::a, enum_A::b, enum_A::c);

// 関数内
enum_A my_enum_A = enum_A::c;
cpp_dump(my_enum_A);
```

![user-defined-enum.png](./readme/user-defined-enum.png)

#### 方法 2. CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC() マクロを使用する

このマクロを使うと指定されたメンバーを持つすべての型を`cpp_dump()`が出力できるようになります。  
このマクロは、ユーザー型がグローバルスコープからアクセス可能であることやユーザー型の型名を必要としません。

このマクロを 2 回以上使用する場合は、Ambiguous function call のコンパイルエラーに注意してください。  
なお、そのようなエラーが発生しても、SFINAE により報告されず、ユーザー型は print できないままです。  
[完全なサンプルコードを見る](./readme/user-defined-class2.cpp)

```cpp
// グローバルスコープ内
// CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(members...)
CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(i, str());

// どこでもよい
struct class_A {
  int i;
  std::string str() const { return std::to_string(i); }
};

// 関数内
class_A my_class_A{10};
cpp_dump(my_class_A);
```

![user-defined-class2.png](./readme/user-defined-class2.png)

#### 3. `std::ostream& operator<<(std::ostream&, const T &)` 演算子を定義する

`std::ostream& operator<<(std::ostream&, const T &)` 演算子を定義することでもユーザー定義型をサポートすることができます。  
[完全なサンプルコードを見る](./readme/user-defined-class3.cpp)

```cpp
// グローバルスコープからアクセス可能な場所（プライベート、または関数内で定義されていない）に配置
struct class_A {
  int i;
  std::string str() const { return std::to_string(i); }
};

// グローバルスコープ
std::ostream &operator<<(std::ostream &os, const class_A &a) {
  os << "class_A{ i= " << a.i << ", str()= \"" << a.str() << "\" }";
  return os;
}

// 関数内
class_A my_class_A{10};
cpp_dump(my_class_A);
```

### `[dump]`をカスタマイズする

`cpp_dump::options::log_label_func` に関数を代入することでカスタマイズできます。  
ライブラリ側で`cpp_dump::options::log_label_func` に代入する関数を作成する関数が用意されているので、自分で関数を作成する必要はありません。

```cpp
namespace cpp_dump::types {

using log_label_func_t =
  std::function<std::string(std::string_view fullpath, std::size_t line, std::string_view func_name)>;

}  // namespace cpp_dump::types

namespace cpp_dump::log_label {

// cpp_dump::options::log_label_func に代入されているデフォルトの関数。
std::string default_func(std::string_view, std::size_t, std::string_view) {
  return "[dump] ";
}

// cpp_dump::options::log_label_func に割り当て可能な関数を作成する関数群。
types::log_label_func_t line(bool show_func = false, int min_width = 0);
types::log_label_func_t basename(bool show_func = false, int min_width = 0);
types::log_label_func_t filename(bool show_func = false, int min_width = 0);
types::log_label_func_t fullpath(int substr_start, bool show_func = false, int min_width = 0);
types::log_label_func_t fixed_length(int min_width, int max_width,
    int substr_start, bool show_func = false);

}  // namespace cpp_dump::log_label

namespace cpp_dump::options {

inline types::log_label_func_t log_label_func = log_label::default_func;

}  // namespace cpp_dump::options
```

### マニピュレーターを使う

マニピュレーターを使うことで、簡単に出力のフォーマットを変更できます。  
たとえば、配列 や map、set のどの、いくつの要素を表示するかを、[`front`、`middle`、`back`、`both_ends` マニピュレーター](#front-middle-back-both_ends-manipulators)で選べます。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
// 1次元目の最後の10要素、2次元目の最初の5要素と最後の5要素を表示します。
cpp_dump(some_huge_vector | cp::back(10) | cp::both_ends(5) | cp::dec(2));
```

![manipulator-front-etc.png](./readme/manipulator-front-etc.png)

また、[`index` マニピュレーター](#index-manipulator)で、配列のインデックスを表示できます。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
CPP_DUMP_SET_OPTION(max_iteration_count, 5);

// ベクターのインデックスを表示します。
cpp_dump(some_huge_vector | cp::dec(2) | cp::index());
```

![manipulator-index.png](./readme/manipulator-index.png)

さらに、[整数のフォーマットを変更するマニピュレーター](#int_style-manipulators)など、他にも多くのマニピュレーターがあります。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
// 2進数、最小16桁表示、4文字ごとに区切る
cpp_dump(0x3e8u | cp::bin(16, 4));
// 8進数、最小6桁表示、3文字ごとに区切る
cpp_dump(0x3e8u | cp::oct(6, 3));
// 16進数、最小4桁表示、2文字ごとに区切る
cpp_dump(0x3e8u | cp::hex(4, 2));
// 最小4桁表示
cpp_dump(0x3e8u | cp::dec(4));
```

![manipulator-int-style.png](./readme/manipulator-int-style.png)

#### マニピュレーターの使用方法

マニピュレーターは`'|'` 演算子か`'<<'` 演算子で使用できます。  
マニピュレーターの適用順序が表示に影響するものとそうでないものがあります。

```cpp
cpp_dump(variable | manipulatorA() | manipulatorB());
cpp_dump(manipulatorA() << manipulatorB() << variable);
```

#### `front()`、`middle()`、`back()`、`both_ends()` マニピュレータ

```cpp
namespace cpp_dump {

front(std::size_t iteration_count = options::max_iteration_count);
middle(std::size_t iteration_count = options::max_iteration_count);
back(std::size_t iteration_count = options::max_iteration_count);
both_ends(std::size_t half_iteration_count = options::max_iteration_count / 2);

}  // namespace cpp_dump
```

これらのマニピュレーターは**適用順序が表示に影響します。**

左側のマニピュレーターから順に配列/Map/Set のより外側の次元に作用します。  
**注意:**  
**`front()` 以外のこれらのマニピュレーターはコンテナのサイズを計算します。`std::size()` でサイズを計算できないコンテナは O(N) の計算コストがかかります。特に、無限のシーケンスをこれらのマニピュレーターに渡すと無限ループになる可能性があります。**  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
// 1次元目の最後の10要素、2次元目の最初の5要素と最後の5要素を表示します。
cpp_dump(some_huge_vector | cp::back(10) | cp::both_ends(5) | cp::dec(2));
```

![manipulator-front-etc.png](./readme/manipulator-front-etc.png)

#### `index()` マニピュレータ

```cpp
cpp_dump::index();
```

`front()`等のマニピュレーターとは異なり、`index()` マニピュレーターは変数内のすべてのシーケンスコンテナに作用します。（順序は関係ありません。）  
このマニピュレータは Map/Set には影響しません。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump(some_huge_vector | cp::dec(2) | cp::index());
```

![manipulator-index.png](./readme/manipulator-index.png)

#### `int_style()` マニピュレータ

```cpp
namespace cpp_dump {

int_style(int base, int digits = -1, int chunk = 0,
    bool space_fill = false, bool make_unsigned_or_no_space_for_minus = false);

bin(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(2, digits, chunk, space_fill, false);
}
oct(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(8, digits, chunk, space_fill, false);
}
hex(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(16, digits, chunk, space_fill, false);
}
dec(int digits = -1, int chunk = 0, bool space_fill = true) {
  return int_style(10, digits, chunk, space_fill, false);
}

ubin(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(2, digits, chunk, space_fill, true);
}
uoct(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(8, digits, chunk, space_fill, true);
}
uhex(int digits = -1, int chunk = 0, bool space_fill = false) {
  return int_style(16, digits, chunk, space_fill, true);
}
udec(int digits = -1, int chunk = 0, bool space_fill = true) {
  return int_style(10, digits, chunk, space_fill, true);
}

}  // namespace cpp_dump
```

`int_style()` の `base` パラメーターは数値の基数を決めるもので `2`、`8`、`10`、`16` の値をサポートしています。他の値では、このマニピュレーターは何も行いません。  
`digits` パラメーターは `digits` >= 0 と `digits` <= '最大桁数' の値をサポートします。ここで '最大桁数' は、指定された `base` に対して型が表現できる最大桁数です。他の値がセットされた場合は `digits` = '最大桁数' として扱われます。  
`chunk` パラメーターは `chunk` >= 0 の値をサポートします。他の値は `chunk` = 0 として扱われます。

`index()` マニピュレーターと同様に、`int_style()` マニピュレーターは変数内のすべての整数に作用します。（順序は関係ありません。）  
`bin(...)`、`oct(...)`、`hex(...)`、`ubin(...)`、`uoct(...)`、`uhex(...)`、`dec(...)`、`udec(...)` は `int_style(...)` のエイリアスです。

符号付き整数型に対しては、`bin()`、`oct()`、`hex()`、`dec()` マニピュレーターが正の値には余分なスペースを追加し、負の値にはマイナス記号を追加します。  
符号なし整数型に対しては、これらのマニピュレーターは余分なスペースやマイナス記号を追加しません。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump(signed_int_vector | cp::front(2) | cp::hex(2));
cpp_dump(unsigned_int_vector | cp::front(2) | cp::hex(2));
cpp_dump(signed_int_vector | cp::front(2) | cp::dec(2));
cpp_dump(unsigned_int_vector | cp::front(2) | cp::dec(2));
```

![manipulator-bin-etc.png](./readme/manipulator-bin-etc.png)

`ubin()`、`uoct()`、`uhex()` マニピュレーターは、すべての整数型を符号なし整数として解釈します。  
元の型が符号なしでない場合、'u' のサフィックスが表示されます。  
ただし、`udec()` マニピュレーターはこれらとは違います。
`udec()`マニピュレーターは符号付き型を符号付き型として解釈しますが、正の値にはマイナスのためのスペースを追加しません。  
これは、負の値を持たない符号付き整数のコンテナを表示するのに適しています。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump(signed_int_vector | cp::front(2) | cp::uhex());
cpp_dump(unsigned_int_vector | cp::front(2) | cp::uhex(2));
cpp_dump(signed_int_vector | cp::front(2) | cp::udec(2));
cpp_dump(unsigned_int_vector | cp::front(2) | cp::udec(2));
```

![manipulator-ubin-etc.png](./readme/manipulator-ubin-etc.png)

#### `format()` マニピュレータ

```cpp
cpp_dump::format(const char *f);
```

このマニピュレーターは `snprintf()` を使用して数値（整数および浮動小数）をフォーマットします。  
フォーマット指定子で指定された型が実際の型と一致していることを確認してください。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump(pi | cp::format("%.10f"));
```

![manipulator-format.png](./readme/manipulator-format.png)

#### `bw()`、`boolnum()` マニピュレータ

```cpp
cpp_dump::bw(bool left = false);
cpp_dump::boolnum();
```

これらのマニピュレーターは bool 型のフォーマットに使用します。  
`bw()` マニピュレーターは、bool 値が `true` の場合に `false` の幅に合わせてスペースを追加します。  
`bw` は「bool width」の略です。  
`boolnum()` マニピュレーターは、bool 値を `1` または `0` として表示します。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump(bool_vector | cp::bw());
cpp_dump(bool_vector | cp::bw(true));
cpp_dump(bool_vector | cp::boolnum());
```

![manipulator-bw-boolnum.png](./readme/manipulator-bw-boolnum.png)

#### `stresc()` マニピュレータ

```cpp
cpp_dump::stresc();
```

このマニピュレーターは文字列をエスケープします。  
エスケープされた文字には 'escaped_char' カラーが使用されます。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
cpp_dump("\a\t\\\"\n\x7f need to be escaped.");
cpp_dump("\a\t\\\"\n\x7f need to be escaped." | cp::stresc());
```

![manipulator-stresc.png](./readme/manipulator-stresc.png)

#### `charhex()` マニピュレータ

```cpp
cpp_dump::charhex();
```

このマニピュレーターは char をその 16 進数と一緒に表示します。
このマニピュレータを使った時、文字列表現の幅は固定されます。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
for (auto c : "\a\t\\\"\n\x7f ABC") cpp_dump(c | cp::charhex());
```

![manipulator-charhex.png](./readme/manipulator-charhex.png)

#### `addr()` マニピュレータ

```cpp
cpp_dump::addr(std::size_t depth = 0);
```

このマニピュレーターはポインタのアドレスを表示します。  
`depth` パラメーターを使用して、アドレスを表示するポインタの深さを指定します。  
[完全なサンプルコードはこちら](./readme/formatting-with-manipulators.cpp)

```cpp
int my_int = 15;
int *int_ptr = &my_int;
int **int_ptr_ptr = &int_ptr;

cpp_dump(int_ptr_ptr);
cpp_dump(int_ptr_ptr | cp::addr());
cpp_dump(int_ptr_ptr | cp::addr(1));
```

![manipulator-addr.png](./readme/manipulator-addr.png)

#### `map_*()` マニピュレータ

```cpp
cpp_dump::map_k(return_value_of_manipulator);
cpp_dump::map_v(return_value_of_manipulator);
cpp_dump::map_kv(return_value_of_manipulator_for_key, return_value_of_manipulator_for_value);
```

これらのマニピュレーターは**適用順序が表示に影響します。**

これらのマニピュレーターは (multi)map に作用します。  
以下の例では、キーが 16 進数で表示され、値がコンテナの場合は値の前部が省略されます。

```cpp
cpp_dump(cp::front() << cp::map_kv(cp::hex(), cp::back()) << map);
cpp_dump(map | cp::front() | cp::map_kv(cp::hex(), cp::back()));
```

### 出力先を標準エラー出力から変更する

出力先を変更するには、`cpp_dump::write_log()` の `void` での明示的特殊化を定義します。

```cpp
// ヘッダーファイルにこれを書いてもかまいません。
// ソースファイルに書く場合は、inline キーワードを削除できます。
template <>
inline void cpp_dump::write_log(std::string_view output) {
  elsewhere << output << std::endl;
}
```

## 競技プログラミングでの便利な使い方

競プロでは、`cpp_dump()`と打つのは長いので、マクロで`dump()`と短くしてしまいましょう。

```cpp
#define dump(...) cpp_dump(__VA_ARGS__)
```

また、提出時にはダンプ関連のコードは消えるようにしておくと便利です。  
具体的には、以下のようにします。

```cpp
#ifdef DEFINED_ONLY_IN_LOCAL
#include "./cpp-dump/dump.hpp"
#define dump(...) cpp_dump(__VA_ARGS__)
namespace cp = cpp_dump;
CPP_DUMP_SET_OPTION_GLOBAL(max_line_width, 80);
CPP_DUMP_SET_OPTION_GLOBAL(log_label_func, cp::log_label::filename());
CPP_DUMP_SET_OPTION_GLOBAL(enable_asterisk, true);
#else
#define dump(...)
#define CPP_DUMP_SET_OPTION(...)
#define CPP_DUMP_DEFINE_EXPORT_OBJECT(...)
#define CPP_DUMP_DEFINE_EXPORT_ENUM(...)
#define CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(...)
#endif

#include <bits/stdc++.h>

#define rep(i, n) for (int i = 0; i < (int)(n); ++i)

using namespace std;

int main() {
  int N;
  cin >> N;

  vector<int> X(N);
  rep(i, N) { cin >> X[i]; }
  dump(X);

  // 続く...
}
```

コンパイル時は、`-D DEFINED_ONLY_IN_LOCAL`をオプションにつけて実行します。
すると、提出時には、dump()マクロが消えるようになります！！

```cpp
g++ main.cpp -D DEFINED_ONLY_IN_LOCAL
```

または

```shell
clang++ ./main.cpp -D DEFINED_ONLY_IN_LOCAL
```

## 終わりに

良かったら GitHub スターをくれると嬉しいです！

https://github.com/philip82148/cpp-dump
