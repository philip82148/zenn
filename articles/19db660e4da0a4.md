---
title: "【C++】あらゆる変数をprintするdump関数を本気で作ってみた"
emoji: "⛳"
type: "tech"
topics:
  - "cpp"
  - "競技プログラミング"
  - "atcoder"
published: true
published_at: "2023-09-27 13:55"
---

## はじめに

Python の`print()`、JavaScript の`console.log()`、PHP の`var_dump()`はあらゆる型の変数を print できる関数です。これらはデバッガのようにセットアップしたり、ブレークポイントを設定したりせずにすぐに変数の中身を確認することができ、デバッグの手段としてめちゃくちゃ便利です。

でも、C++にはこんな関数はありません。なので、例えば vector の中身を print したい！と思っても、**いちいち for ループを書いて、cout << a[i] << endl;なんてやらなければなりません。** もし Python みたいに`print(変数名1, 変数名2, ...)`とするだけで、あらゆる変数の中身を表示することが出来たら…。

そこで、あらゆる型に対応した C++のダンプ関数を**本気で作ってみました！**
今回作ったダンプ関数の特徴はこんな感じです。

- 多次元配列や多次元の(多重)マップ、(多重)セット、タプル、複素数やエラーオブジェクトまで、**どんな型の変数でも**、文字列表現にして標準エラー出力(カスタマイズ可能)に出力する。
- **自動インデント機能付き。** 設定した行幅に収まるように自動でインデントされ、ネストしたコンテナも読みやすいようにフォーマットされる。
- 変数の文字列表現は JavaScript や Python, C++のシンタックスに似ていて、**情報が多すぎて見づらくなることもない、読みやすい出力。** (マニピュレータで情報を付加することもできる)
- **出力は色付きで、カスタマイズ可能。** IDE のシンタックスハイライトのような色付けも可能。
- **20 個以上のマニピュレータ付き**で簡単に出力のフォーマットを変えたり情報を付加したりできる。
- マクロを使うか演算子を定義すると**ユーザー定義型もダンプできる。** 新しく関数を書いたりする必要はない。
- **ヘッダーオンリーライブラリ**で、ビルドなどは不要。

https://github.com/philip82148/cpp-dump

## 使い方

`cpp_dump(expr...)`マクロに変数を渡すだけです！
[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/introduction.cpp)

```cpp
std::vector<std::vector<int>> my_vector{{3, 5, 8, 9, 7}, {9, 3, 2, 3, 8}};
cpp_dump(my_vector);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/macro-version.png?3)

## このダンプ関数の特徴

### 多次元配列や多次元の(multi)map、(multi)set、tuple、pair、複素数やエラーオブジェクト等、あらゆる型に対応

対応している型は vector だけではありません。map, set, tuple, pair など、ありとあらゆる型に対応しています。  
[サポートしている全ての型を見る](https://github.com/philip82148/cpp-dump?tab=readme-ov-file#supported-types)
[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/supports-various-types.cpp)

```cpp
// 変数の定義はサンプルコードを見てください
std::clog << "\n// Basic Type" << std::endl;
cpp_dump(false, 0, 0.0); cpp_dump(true, 3.14, my_int, -9265);
cpp_dump("This is a string.", 'a', '\n'); cpp_dump(ptr, void_ptr, nullptr);

std::clog << "\n// Container" << std::endl;
cpp_dump(my_vector);

std::clog << "\n// Set/Map" << std::endl;
cpp_dump(my_set); cpp_dump(my_map);

std::clog << "\n// Multiset/Multimap" << std::endl;
cpp_dump(my_multiset); cpp_dump(my_multimap);

std::clog << "\n// Tuple" << std::endl;
cpp_dump(my_tuple); cpp_dump(my_pair);

std::clog << "\n// FIFO/LIFO" << std::endl;
cpp_dump(my_queue); cpp_dump(my_priority_queue); cpp_dump(my_stack);

std::clog << "\n// Other" << std::endl;
cpp_dump(my_bitset); cpp_dump(my_complex);
cpp_dump(my_optional, std::nullopt); cpp_dump(my_variant);

std::clog << "\n// Combination" << std::endl;
cpp_dump(vector_of_pairs);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/supports-various-types.png?6)

対応する全ての型の一覧は[ライブラリの README](https://github.com/philip82148/cpp-dump#supported-types)にあります。

### 設定した行幅に収まるように自動でインデント

[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/auto-indent.cpp)

```cpp
std::vector<std::string> my_vector(3, "This is a test string.");
cpp_dump(my_vector);

my_vector.push_back("This is a test string.");
cpp_dump(my_vector);
```

このように要素を追加して行幅を超えそうになると、、  
![](https://github.com/philip82148/cpp-dump/raw/main/readme/auto-indent.png?3)
**自動でインデントされます！！**  
ちなみに多次元配列などは最初から改行されます(設定変更可能)。

### `[dump]`の代わりにファイル名や行数を表示させることも可能。

`[dump]`の代わりにファイル名や行数を表示させることも可能です。
その場合は以下のコードで設定します。
[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/customize-dump.cpp)

```cpp
// Print the filename and line instead of [dump]
CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename());
// Print along with the function name
CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename(true));
```

![](https://github.com/philip82148/cpp-dump/blob/main/readme/customize-dump.png)

### 出力のカラーリングはカスタマイズ可能

以下のコードのようにすることで出力のカラーリングをカスタマイズできます。
[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/customizable-colors.cpp)

```cpp
// 色数を増やす
CPP_DUMP_SET_OPTION(es_value, (cp::types::es_value_t{
  "\x1b[02m",        // log: dark
  "\x1b[34m",        // expression: blue
  "\x1b[38;5;39m",   // reserved: light blue
  "\x1b[38;5;193m",  // number: light green
  "\x1b[38;5;172m",  // character: orange
  "\x1b[02m",        // op: dark
  "\x1b[32m",        // identifier:  green
  "\x1b[96m",        // member: light cyan
  "\x1b[31m",        // unsupported: red
  {
    "\x1b[33m",      // bracket_by_depth[0]: yellow
    "\x1b[35m",      // bracket_by_depth[1]: magenta
    "\x1b[36m",      // bracket_by_depth[2]: cyan
  },
  "\x1b[02m",        // class_op: dark
  "\x1b[02m",        // member_op: dark
  "",                // number_op: default
  "\x1b[38;5;220m"   // escaped_char: light orange
}));

// クラスやメンバ、数値の演算子(::, <>, (), -, +, etc...)に
// 色(class_op, member_op, number_op)を付ける
CPP_DUMP_SET_OPTION(detailed_class_es, true);
CPP_DUMP_SET_OPTION(detailed_member_es, true);
CPP_DUMP_SET_OPTION(detailed_number_es, true);

// IDEのシンタックスハイライトのようなカラーリングにする
// CPP_DUMP_SET_OPTION(es_style, cp::types::es_style_t::by_syntax);
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/customizable-colors.png?6)

### 自作クラスも対応させることが可能

マクロを使うか演算子を定義することで、自作クラスも対応させることが可能です。
[サンプルコードを見る](https://github.com/philip82148/cpp-dump/blob/main/readme/user-defined-class2.cpp)

```cpp
CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(i, str());
```

![](https://github.com/philip82148/cpp-dump/raw/main/readme/user-defined-class2.png?2)

### 20 個以上のマニピュレータ

このライブラリには 20 個以上のマニピュレータがあり、簡単にフォーマットを変更したり、情報を付加したりすることができます。
![](https://github.com/philip82148/cpp-dump/blob/main/readme/manipulator-front-etc.png)
_配列の一部を省略するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/raw/main/readme/manipulator-index.png?1)
_配列のインデックスを表示するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/blob/main/readme/manipulator-ubin-etc.png?1)
_数値の基数を変更するマニピュレータ_

## このライブラリを使うのに必要な要件

- C++17 以上

## インストール方法

1. リポジトリを好きな場所にダウンロードします。

**git が使える人は**

```shell
git clone https://github.com/philip82148/cpp-dump
```

**git が使えない人は**
[Releases](https://github.com/philip82148/cpp-dump/releases)からソースフォルダをダウンロードして、好きな場所に解凍しましょう。

2. ソースファイル内で、`cpp-dump/dump.hpp`を include します。

```cpp
#include "path/to/cpp-dump/dump.hpp"
```

ダウンロードしたフォルダ内にある`dump.hpp`というファイルをソースフォルダ内で include します。  
※パスは自身の環境に合わせて変えてください。

3. あとはソースファイル内で関数を呼び出すだけ！

```cpp
cpp_dump(変数1, 変数2, ...);
```

ヘッダーオンリーライブラリなので、ビルド等は不要です！

## カスタマイズ方法()

カスタマイズする際は、CPP_DUMP_SET_OPTION_GLOBAL()で設定を行います。

```cpp:custom-cpp-dump.hpp
#ifdef DEBUGGING
#include "path/to/cpp-dump/cpp-dump.hpp"
namespace cp = cpp_dump;
CPP_DUMP_SET_OPTION_GLOBAL(max_line_width, 100);
// CPP_DUMP_DEFINE_EXPORT_ENUM(...);
// CPP_DUMP_DEFINE_EXPORT_OBJECT(...);
// CPP_DUMP_DEFINE_EXPORT_OBJECT_GENERIC(...);
#else
#define cpp_dump(...)
#define CPP_DUMP_SET_OPTION(...)
#endif
```

```cpp:main.cpp
#include "path/to/custom-cpp-dump.hpp"

int main() {
  cpp_dump(vec | cp::back());
}
```

関数の中で設定を変更したい場合は`CPP_DUMP_SET_OPTION()`を使います。

```cpp:main.cpp
#include "path/to/custom-cpp-dump.hpp"

void func() {
  CPP_DUMP_SET_OPTION(print_expr, false);
  cpp_dump(vec | cp::back());
  CPP_DUMP_SET_OPTION(print_expr, true);
}
```

### 設定可能項目

#### `max_line_width`

型: `std::size_t` デフォルト値: `160`

`cpp_dump()`と、その内部で使われている`cpp_dump::export_var()`が出力する文字列の最大行幅。

#### `max_depth`

型: `std::size_t` デフォルト値: `4`

`cpp_dump::export_var()`が再帰的に呼び出される最大の回数。

#### `max_iteration_count`

型: `std::size_t` デフォルト値: `16`
コンテナなどで、`cpp_dump::export_var()`をイテレーションする回数。`cpp_dump::export_var()`の一回の呼び出しで`cpp_dump::export_var()`は最大(`max_iteration_count`^(`max_depth`+1)-1)/(`max_iteration_count`-1)-1 回呼び出される。

#### `enable_asterisk`

型: `bool` デフォルト値: `false`
`cpp_dump::export_var()`が型カテゴリ Asterisk をプリントするかどうか。(詳細は[README の Supported types](#supported-types)を参照)

#### `print_expr`

型: `bool` デフォルト値: `true`
`cpp_dump()`が式を表示するかどうか。

#### `log_label_func`

型: `cpp_dump::types::log_label_func_t` デフォルト値 `cpp_dump::log_label::default_func`  
`cpp_dump()`が出力の最初にプリントするラベルを返す関数。

#### `es_style`

型: `enum class cpp_dump::types::es_style_t` デフォルト値`cpp_dump::types::es_style_t::original`  
出力のカラースキーム。

| Name        | Description                                                                                                         |
| ----------- | ------------------------------------------------------------------------------------------------------------------- |
| `original`  | デフォルト値                                                                                                        |
| `by_syntax` | 標準的なシンタックスハイライトと同様の色付けにする。ポインタや bitset、complex などが`original`とは違う色付けになる |
| `no_es`     | 色付けをオフにする                                                                                                  |

#### `es_value`

型: `cpp_dump::types::es_value_t` デフォルト値: (デフォルトコンストラクタ、[型](#types)を参照)  
エスケープシーケンスの値。

#### `detailed_class_es`

型: `bool` デフォルト値: `false`  
`true` に設定すると、クラス名内の演算子 (`::`、`<>` など) に 'class_op' カラーが使用されます。

#### `detailed_member_es`

型: `bool` デフォルト値: `false`  
`true` に設定すると、メンバー内の演算子 (`()` など) に 'member_op' カラーが使用されます。

#### `detailed_number_es`

型: `bool` デフォルト値: `false`  
`true` に設定すると、数値内の演算子 (`-`、`+` など) に 'number_op' カラーが使用されます。

#### `cont_indent_style`

型: `enum class cpp_dump::types::cont_indent_style_t` デフォルト: `cpp_dump::types::cont_indent_style_t::when_nested`  
コンテナ、セット、マップカテゴリーのインデントスタイル ([対応する型](#supported-types)参照)。

| 名前                     | 説明                                                                                                                                           |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `minimal`                | `max_line_width` が超えない限りインデントしない                                                                                                |
| `when_nested`            | デフォルト。要素/キー/値の型がコンテナ/セット/マップ/タプルカテゴリーに該当する場合に常にインデントします。                                    |
| `when_non_tuples_nested` | 要素/キー/値の型がコンテナ/セット/マップカテゴリーに該当する場合は常にインデントしますが、タプルカテゴリーに該当する場合はインデントしません。 |
| `always`                 | コンテナ/セット/マップがネストされていなくても常にインデントします。                                                                           |

## 競技プログラミングでの便利な使い方

競プロでは、`cpp_dump()`と打つのは長いので、マクロで`dump()`と短くしてしまいましょう。

```cpp
#define dump(...) cpp_dump(__VA_ARGS__)
```

また、提出時にはダンプ関連のコードは消えるようにしておくと便利です。  
具体的には、以下のようにします。

```cpp
#ifdef DEFINED_ONLY_IN_LOCAL
#include "./cpp-dump/dump.hpp"
#define dump(...) cpp_dump(__VA_ARGS__)
namespace cp = cpp_dump;
#else
#define dump(...)
#define CPP_DUMP_SET_OPTION(...)
#define CPP_DUMP_DEFINE_EXPORT_OBJECT(...)
#define CPP_DUMP_DEFINE_EXPORT_ENUM(...)
#define CPP_DUMP_DEFINE_DANGEROUS_EXPORT_OBJECT(...)
#endif

#include <bits/stdc++.h>

#define rep(i, n) for (int i = 0; i < (int)(n); ++i)

using namespace std;

int main() {
  CPP_DUMP_SET_OPTION(max_line_width, 80);
  CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename());
  CPP_DUMP_SET_OPTION(enable_asterisk, true);

  int N;
  cin >> N;

  vector<int> X(N);
  rep(i, N) { cin >> X[i]; }
  dump(X);

  // 続く...
}
```

コンパイル時は、`-D DEFINED_ONLY_IN_LOCAL`をオプションにつけて実行します。
すると、提出時には、dump()マクロが消えるようになります！！

```cpp
g++ main.cpp -D DEFINED_ONLY_IN_LOCAL
```

## 終わりに

良かったら GitHub スターをくれると嬉しいです！

https://github.com/philip82148/cpp-dump
