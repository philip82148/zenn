---
title: "【GitHubスター100個突破】Pythonのprint()のC++版を本気で作ってみた"
emoji: "⛳"
type: "tech"
topics:
  - "cpp"
  - "python"
  - "競技プログラミング"
  - "atcoder"
published: true
published_at: "2023-10-24 17:20"
---

## はじめに

※2023/10/24:記事を Qiita から Zenn に移しました。

Python の`print()`は数値でも文字列でも配列でも、**どのような型の変数でも文字列にしてくれて**すごく便利です。

僕は競プロ(競技プログラミング)をやっているのですが、時間との闘いである競プロでは、このようなあらゆる変数表示が出来る関数はデバッグにとても重宝します。

しかし、C++にはそのような関数はありません。特に C++は高速で競プロに向いている言語なので、C++にそのような関数がないのはとてももったいないです。

だったら作ればいいじゃない、ということで、**`print()`の C++バージョンを本気で作ってみました！**

今回作った`print()`の C++バージョンの特徴はこんな感じです。

- 多次元配列や多次元の(多重)マップ、(多重)セット、タプル、複素数やエラーオブジェクトまで、**どんな型の変数でも**、文字列表現にして標準エラー出力(std::clog)に出力する。
- 行幅が設定でき、**自動でインデントを行う。**
- **出力は色付きで、カスタマイズ可能。**
- **ヘッダーオンリーライブラリ**で、ビルドなどは不要。
- マクロを使うか演算子を定義すると**ユーザー定義型もプリントできる。**
- 変数の文字列表現は**JavaScript と Python, C++のシンタックス**に似ている。
- 表示方法を変更する**マニピュレータ付き。**

https://github.com/philip82148/cpp-dump

## まずはテストコード！

説明はいいから試したい！っていう人はこのセクションを読んでください。
詳しいインストール方法・このライブラリの特徴が知りたい人はこのセクションは飛ばして次のセクションから読んでくださいね。

次のコマンドをターミナルで実行して、、
(git が使えない人は次のセクションを参照してください)

```shell
git clone https://github.com/philip82148/cpp-dump
```

以下をコピペしてコンパイル&実行します。

```cpp
#include <bitset>
#include <complex>
#include <map>
#include <optional>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <tuple>
#include <utility>
#include <variant>
#include <vector>

#include "./cpp-dump/dump.hpp"

int main() {
  int my_int = 15;
  int *ptr = &my_int;
  void *void_ptr = &my_int;
  std::vector<std::vector<int>> my_vector{{3, 5, 8, 9, 7}, {9, 3, 2, 3, 8}};
  std::set<char> my_set{'A', 'p', 'p', 'l', 'e'};
  std::map<int, int> my_map{{2, 6}, {4, 6}, {5, 3}};
  std::multiset<char> my_multiset{'A', 'p', 'p', 'l', 'e'};
  std::multimap<int, int> my_multimap{{2, 4}, {4, 6}, {5, 3}, {4, 7}};
  std::pair<int, char> my_pair{8, 'a'};
  std::tuple<int, double, std::string> my_tuple{7, 4.5, "This is a string."};
  std::queue<int> my_queue;
  std::priority_queue<int> my_priority_queue;
  std::stack<int> my_stack;
  for (auto v : {1, 2, 3, 4, 5}) my_queue.push(v), my_priority_queue.push(v), my_stack.push(v);
  std::bitset<8> my_bitset(0x3a);
  std::complex<double> my_complex{1.0, 1.0};
  std::optional<int> my_optional{15};
  std::variant<int, std::string> my_variant{"1"};
  std::vector<std::pair<int, std::string>> vector_of_pairs{{1, "apple"}, {3, "banana"}};

  std::clog << "\n// Basic Type" << std::endl;
  cpp_dump(false, 0, 0.0, '0'), cpp_dump(true, 3.14, my_int, 9265);
  cpp_dump("This is a string."), cpp_dump(ptr, void_ptr, nullptr);

  std::clog << "\n// Container" << std::endl;
  cpp_dump(my_vector);

  std::clog << "\n// Set/Map" << std::endl;
  cpp_dump(my_set), cpp_dump(my_map);

  std::clog << "\n// Multiset/Multimap" << std::endl;
  cpp_dump(my_multiset), cpp_dump(my_multimap);

  std::clog << "\n// Tuple" << std::endl;
  cpp_dump(my_tuple), cpp_dump(my_pair);

  std::clog << "\n// FIFO/LIFO" << std::endl;
  cpp_dump(my_queue), cpp_dump(my_priority_queue), cpp_dump(my_stack);

  std::clog << "\n// Other" << std::endl;
  cpp_dump(my_bitset), cpp_dump(my_complex);
  cpp_dump(my_optional, std::nullopt), cpp_dump(my_variant);

  std::clog << "\n// Combination" << std::endl;
  cpp_dump(vector_of_pairs);

  std::clog << std::endl;
}
```

すると、このように print されます！
![](https://github.com/philip82148/cpp-dump/raw/main/readme/supports-various-types.png?5)

## 詳しいインストール方法

1. リポジトリを好きな場所にダウンロードします。
   下記をターミナルで実行するか、[Releases](https://github.com/philip82148/cpp-dump/releases)からソースフォルダ(Source code と書かれたもの)をダウンロードして好きな場所に解凍してください。

```shell
git clone https://github.com/philip82148/cpp-dump
```

2. ソースファイルで`cpp-dump/dump.hpp`をインクルードすると、`cpp_dump()`が使えるようになります！

```cpp
#include "path/to/cpp-dump/dump.hpp"
```

※パスはダウンロードした場所に合わせて変えてください。

## 使い方！

`cpp_dump(expr...)`マクロに変数を渡すだけです！

```cpp
// In main() or some function
std::vector<std::vector<int>> my_vector{{3, 5, 8, 9, 7}, {9, 3, 2, 3, 8}};
cpp_dump(my_vector);
```

![](https://storage.googleapis.com/zenn-user-upload/912ef56132eb-20231023.png)

## このライブラリの特徴 7 つ(以上)

このライブラリの特徴について説明します。

### 1. Python ライクな文字列表現

本物の`print()`のように**Python っぽい文字列表現**で出力します。
![](https://storage.googleapis.com/zenn-user-upload/0a8c0878ecf0-20231023.png)
_std::vector、std::array、配列などのループ可能なオブジェクトの場合_
![](https://storage.googleapis.com/zenn-user-upload/c45b2b501604-20231023.png)
_std::map、std::unordered_map の場合_
![](https://storage.googleapis.com/zenn-user-upload/43c61d5a33dd-20231023.png)
_std::tuple または std::pair の場合_
![](https://storage.googleapis.com/zenn-user-upload/63bcd36cc6d5-20231023.png)
_std::set、std::unordered_set の場合_

### 2. 内容量が多いと自動的にインデント

内容量が多くて行幅を超えそうな場合は**自動でインデント**されます！  
これ、もとの Python の`print()`にはない機能です！
![](https://storage.googleapis.com/zenn-user-upload/af28a8692dcd-20231023.png)
_std::vector、std::array などのループ可能なオブジェクトや std::tuple や std::set など_
![](https://storage.googleapis.com/zenn-user-upload/4b05978a3917-20231023.png)
_std::map、std::unordered_map の場合_

行幅の設定は次のコードで行えます。

```cpp
CPP_DUMP_SET_OPTION(max_line_width, 行幅の文字数);
```

デフォルトでは 160 が設定されています。競プロで提出時に無効化できるようにマクロを作りましたが、普通に代入操作で設定することも可能です。詳しくはリポジトリの[README](https://github.com/philip82148/cpp-dump#variables)を参照してください。

### 3. `[dump]`の代わりにファイル名と行数も print 可能

次のコードを使うことで、`[dump]`の代わりにファイル名と行数もプリント可能です！
詳しくは[リポジトリの README](https://github.com/philip82148/cpp-dump#filename-and-line-can-be-printed-instead-of-dump)をご覧ください!

```cpp
CPP_DUMP_SET_OPTION(log_label_func, cpp_dump::log_label::filename());
```

![](https://storage.googleapis.com/zenn-user-upload/f580e174b4e3-20231203.png)

### 4. 再帰的に出力するので、多次元配列やネストされた型も出力可能

そのほか、std::multimap や std:queue、std::complex など**ありとあらゆる型に対応しています!**
対応している型については[リポジトリの README](https://github.com/philip82148/cpp-dump#supported-types)をご覧ください！
![](https://storage.googleapis.com/zenn-user-upload/912ef56132eb-20231023.png)
![](https://storage.googleapis.com/zenn-user-upload/0c38092e8ffd-20231023.png)

### 5. ユーザー型も print 可能！

マクロを使ったり、オペレータを定義したりすることでユーザー型も print 可能です！
詳しくは[リポジトリの README](https://github.com/philip82148/cpp-dump#can-print-even-user-defined-types)をご覧ください!

```cpp
CPP_DUMP_DEFINE_DANGEROUS_EXPORT_OBJECT(i, str());
```

![supports-various-types.png](https://github.com/philip82148/cpp-dump/raw/main/readme/user-defined-class2.png?1)

### 6. 出力の色はカスタマイズ可能

**出力の色はカスタマイズすることができます！**  
写真は一例です。
詳しくは[リポジトリの README](https://github.com/philip82148/cpp-dump#customizable-output-colors)をご覧ください。
![](https://github.com/philip82148/cpp-dump/raw/main/readme/customizable-colors.png?5)

### 7~. その他にもカスタマイズ可能な機能や便利な機能あり

その他、表示を変えるマニピュレータなど便利な機能があります！
詳しくは[リポジトリの README](https://github.com/philip82148/cpp-dump#usage)をご覧ください！
![](https://github.com/philip82148/cpp-dump/raw/main/readme/manipulators.png?1)
_配列の一部を省略するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/raw/main/readme/int-style.png?1)
_2 進数で表示するマニピュレータ_
![](https://github.com/philip82148/cpp-dump/raw/main/readme/cont-index.png?1)
_配列のインデックスを表示するマニピュレータ_

## 競プロでの便利な使い方

競プロでは、`cpp_dump()`は長いので、マクロで`dump()`と短くしてしまいましょう。
また、提出時には`dump()`が消えるように以下のようにします。

```cpp
#ifdef DEFINED_ONLY_IN_LOCAL
#include "./cpp-dump/dump.hpp"
#define dump(...) cpp_dump(__VA_ARGS__)
namespace cp = cpp_dump;
#else
#define dump(...)
#define CPP_DUMP_SET_OPTION(...)
#define CPP_DUMP_DEFINE_EXPORT_OBJECT(...)
#define CPP_DUMP_DEFINE_EXPORT_ENUM(...)
#define CPP_DUMP_DEFINE_DANGEROUS_EXPORT_OBJECT(...)
#endif

#include <bits/stdc++.h>

#define rep(i, n) for (int i = 0; i < (int)(n); ++i)

using namespace std;

int main() {
  CPP_DUMP_SET_OPTION(max_line_width, 80);
  CPP_DUMP_SET_OPTION(log_label_func, cp::log_label::filename());
  CPP_DUMP_SET_OPTION(enable_asterisk, true);

  int N;
  cin >> N;

  vector<int> X(N);
  rep(i, N) { cin >> X[i]; }
  dump(X);

  // 続く...
}
```

そして、ローカルでコンパイルするときは以下のようにすることで、ローカルでだけ`dump()`マクロが動くようになります！

```shell
g++ ./main.cpp -D DEFINED_ONLY_IN_LOCAL
```

or

```shell
clang++ ./main.cpp -D DEFINED_ONLY_IN_LOCAL
```

## 終わりに

良ければ GitHub スターをくれると嬉しいです！

https://github.com/philip82148/cpp-dump

## 関連記事

https://zenn.dev/sassan/articles/19db660e4da0a4
